package com.java.redis.book.theDesignAndImplementationOfRedis;

/**
 * 压缩列表(ziplist)
 * 压缩列表是列表键和哈希键的底层实现之一
 * 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现
 * 当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现
 * 压缩列表是Redis为了节约内存儿开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构，
 * 一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值
 * 
 * 压缩列表是连续内存块，从前到后依次是：zlbytes、zltail、zllen、entryX和zlend，其中
 * zlbytes，类型是uint32_t，长度4字节，用来记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配，或者计算zlend的位置时使用
 * zltail，类型是uint32_t，长度4字节，用来记录压缩列表表尾节点距离压缩列表的起始地址有多少个字节，通过这个偏移量，
 * 程序无需遍历整个压缩列表就可以确定表尾节点的地址
 * zllen，类型是uint16_t，长度2字节，当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含"节点"的数量，
 * 当这个值等于UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出
 * entryX，类型是列表节点，长度不定，用来记录压缩列表的各个节点，节点的长度由节点保存的内容决定
 * zlend，类型是uint8_t，长度1字节，用来标记压缩列表的末端，是一个特殊值0xFF(十进制255)
 * 
 * 压缩列表节点的构成
 * 每个压缩列表可以保存一个字节数组或一个整数值，
 * 其中，字节数组可以是以下三种长度之一
 * 1.长度小于等于63(2的6次方-1)字节的字节数组
 * 2.长度小于等于16 383(2的14次方-1)字节的字节数组
 * 3.长度小于等于4 294 967 295(2的32次方-1)字节的字节数组
 * 而整数值则可以是以下六种长度之一
 * 1.4位长，介于0到12之间的无符号整数
 * 2.1字节长的有符号整数
 * 3.3字节长的有符号整数
 * 4.int16_t类型整数
 * 5.int32_t类型整数
 * 6.int64_t类型整数
 * 
 * 每个压缩列表节点都由previous_entry_length、encoding和content三部分组成
 * 
 * 节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度，previous_entry_length属性的长度是1字节或5字节
 * 1.如果前一节点长度小于254字节，那么previous_entry_length属性长度为1字节，前一节点的长度就保存在这1字节里面
 * 2.如果前一节点长度大于等于254字节，那么previous_entry_length属性长度为5字节。其中第1字节会被设置为0xFE(254)，之后的4个字节用于保存前一节点的长度
 * previous_entry_length属性保存的是前一节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一节点的起始地址
 * 压缩列表从表尾向表头遍历操作就是通过该属性实现的，指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上zltail属性的值得出
 * 
 * 节点的encoding属性记录了节点的content属性所保存数据的类型及长度
 * 1.encoding值为1字节、2字节或者5字节长，值的最高位为00,01，或者10的是字节数组编码，这种编码表示content属性保存着字节数组，数组的长度由encoding值丢弃最高2位之后的其他位记录
 * 2.encoding值为亲子节长，值的最高位以11开头的是整数编码，这种编码表示content属性保存着整数值，整数值的类型和长度由encoding值丢弃最高2位之后的其他位记录
 * 具体如下
 * 字节数组编码
 * encoding值：00bbbbbb，编码长度：1字节，content属性保存的值：长度小于等于63字节的字节数组
 * encoding值：01bbbbbb xxxxxxxx，编码长度：2字节，content属性保存的值：长度小于等于16 383字节的字节数组
 * encoding值：10______ aaaaaaaa bbbbbbbb cccccccc dddddddd，编码长度：5字节，content属性保存的值：长度小于等于4 294 967 295字节的字节数组
 * 整数编码
 * encoding值：11000000，编码长度：1字节，content属性保存的值：int16_t类型的整数
 * encoding值：11010000，编码长度：1字节，content属性保存的值：int32_t类型的整数
 * encoding值：11100000，编码长度：1字节，content属性保存的值：int64_t类型的整数
 * encoding值：11110000，编码长度：1字节，content属性保存的值：24位有符号整数
 * encoding值：11111110，编码长度：1字节，content属性保存的值：8位有符号整数
 * encoding值：1111xxxx，编码长度：1字节，content属性保存的值：这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位已经保存了一个介于0~12之间的值，所以无须content属性
 * 
 * 节点的content属性负责保存节点的值
 * 
 * 连锁更新
 * Redis在特殊情况下回产生连续多次空间扩展操作，称之为连锁更新。添加节点和删除节点都可能引发连锁更新
 * 最坏情况下，需要对压缩列表执行N次空间重分配操作，而每次空间重分配最坏负责度为O(N)，所以连锁更新的最坏复杂度为O(N²)
 * 虽然连锁更新复杂度较高，但它真正造成性能问题的几率是很低的
 * 1.压缩列表要恰好有多个连续的，长度介于250字节至253字节之间的节点，连锁更新才可能被引发，实际情况中并不多见
 * 2.就算出现连锁更新，只要被更新的节点不多，依然不会对性能造成影响
 * 综上，ziplistPush等命令平均复杂度为O(N)，实际应用中不必担心连锁更新会影响压缩列表的性能
 * 
 * @author ChengHan
 * @date 2018年6月24日 上午10:10:43
 */
public class Chapter7 {

}
